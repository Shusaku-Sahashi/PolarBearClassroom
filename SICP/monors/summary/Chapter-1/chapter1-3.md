# 1.3 高階手続きによる抽象の定式化
下記の様に、手続きは特定の数値から独立した形で記述する抽象化であることをこれまでみてきました。
```lisp
(define (cube x) (* x x x))
```
しかし、下記の様に記述することもできます。
```lisp
(* 3 3 3)
(* x x x)
(* y y y)
```
この記述方法では、３乗という概念を抽象化したものを持たないため、毎回記述しなければならない。
この様に、プログラミングにおいてあるパターンを概念として表現するのは大きな意味を持ちます。
しかし、数値計算であっても、もし引数が数値であるような手続きしか作れないのだとしたら、抽象化の能力は限定されたものになるでしょう。
同じプログラミングパターンがいくつものことなる手続きに利用されることは、よくあります。
この様なパターンを概念として表現するためには、下記に対応する必要があります。
* 手続きを引数として受け取る。
* 手続きを戻り値として返す。

この様に、手続きを操作する手続きは高階手続きと呼ばれます。

## 1.3.1 引数としての手続き
例えば、下記のお通りa ~ bまでの合計値を合算するプログラムがあったとする。
```lisp
(define (sum-interger a b)
  (if (> a b)
      0
      (+ a (sum-interger (+ a 1) b))))
```
この様な計算がある時、下記の様に抽象化が可能である。
```lisp
(define (sum term a next b)
    (if (> a b)
        0
        (+ (term a) (sum term (next a) next b))))
```
これらに方法としては、`term`に任意の関数を代入し、
`next`には、aをどの様にbに近づけるかを定義する。
例えば、下記の様な関数があったとします。

```lisp
(define (pi-sum a b)
  (if (> a b)
      0
      (+ (/ 1.0 ( * a ( + a 2)))
         (pi-sum (+ a 4) b))))
```
この関数は、`sum`を使用することで下記の通り書き換えられる。
```lisp
(define (pi-sum a b)
  (define (pi-term x)
    (/ 1.0 (* x (+ x 2))))

  (define (pi-next x)
    (+ a 4))

  (sum pi-term a pi-next b))
```
※ `pi-term``pi-next`に関しては他の関数では役にたちそうにないため、
  関数内部に定義を押し込めてしまっている。



## 1.3.2 lambdaを使った手続きの構築

## 1.3.3 汎用手法としての手続き

## 1.3.4 戻り値としての手続き

